# 
msgid ""
msgstr ""
"Project-Id-Version: Understanding JSON Schema 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-05-09 06:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/structuring.rst:7
msgid "Structuring a complex schema"
msgstr ""

#: ../../source/structuring.rst:9
msgid ""
"When writing computer programs of even moderate complexity, it's commonly "
"accepted that \"structuring\" the program into reusable functions is better "
"than copying-and-pasting duplicate bits of code everywhere they are used.  "
"Likewise in JSON Schema, for anything but the most trivial schema, it's "
"really useful to structure the schema into parts that can be reused in a "
"number of places.  This chapter will present some practical examples that "
"use the tools available for reusing and structuring schemas."
msgstr ""

#: ../../source/structuring.rst:19
msgid "Reuse"
msgstr ""

#: ../../source/structuring.rst:21
msgid ""
"For this example, let's say we want to define a customer record, where each "
"customer may have both a shipping and a billing address. Addresses are "
"always the same---they have a street address, city and state---so we don't "
"want to duplicate that part of the schema everywhere we want to store an "
"address.  Not only does it make the schema more verbose, but it makes "
"updating it in the future more difficult.  If our imaginary company were to "
"start international business in the future and we wanted to add a country "
"field to all the addresses, it would be better to do this in a single place "
"rather than everywhere that addresses are used."
msgstr ""

#: ../../source/structuring.rst:32
msgid "So let's start with the schema that defines an address::"
msgstr ""

#: ../../source/structuring.rst:44
msgid ""
"Since we are going to reuse this schema, it is customary (but not required) "
"to put it in the parent schema under a key called ``definitions``::"
msgstr ""

#: ../../source/structuring.rst:65
msgid ""
"We can then refer to this schema snippet from elsewhere using the ``$ref`` "
"keyword.  The easiest way to describe ``$ref`` is that it gets logically "
"replaced with the thing that it points to.  So, to refer to the above, we "
"would include::"
msgstr ""

#: ../../source/structuring.rst:72
msgid ""
"The value of ``$ref`` is a string in a format called `JSON Pointer "
"<http://tools.ietf.org/html/draft-pbryan-zyp-json-pointer-02>`__."
msgstr ""

#: ../../source/structuring.rst:76
msgid ""
"JSON Pointer aims to serve the same purpose as `XPath "
"<http://www.w3.org/TR/xpath/>`_ from the XML world, but it is much simpler."
msgstr ""

#: ../../source/structuring.rst:80
msgid ""
"The pound symbol (``#``) refers to the current document, and then the slash "
"(``/``) separated keys thereafter just traverse the keys in the objects in "
"the document.  Therefore, in our example ``\"#/definitions/address\"`` "
"means:"
msgstr ""

#: ../../source/structuring.rst:85
msgid "go to the root of the document"
msgstr ""

#: ../../source/structuring.rst:86
msgid "find the value of the key ``\"definitions\"``"
msgstr ""

#: ../../source/structuring.rst:87
msgid "within that object, find the value of the key ``\"address\"``"
msgstr ""

#: ../../source/structuring.rst:89
msgid ""
"``$ref`` can also be a relative or absolute URI, so if you prefer to include"
" your definitions in separate files, you can also do that.  For example::"
msgstr ""

#: ../../source/structuring.rst:95
msgid ""
"would load the address schema from another file residing alongside this one."
msgstr ""

#: ../../source/structuring.rst:98
msgid ""
"Now let's put this together and use our address schema to create a schema "
"for a customer:"
msgstr ""

#: ../../source/structuring.rst:140
msgid "Extending"
msgstr ""

#: ../../source/structuring.rst:142
msgid ""
"The power of ``$ref`` really shines when it is combined with the combining "
"keywords ``allOf``, ``anyOf`` and ``oneOf`` (see :ref:`combining`)."
msgstr ""

#: ../../source/structuring.rst:146
msgid ""
"Let's say that for shipping address, we want to know whether the address is "
"a residential or business address, because the shipping method used may "
"depend on that.  For the billing address, we don't want to store that "
"information, because it's not applicable."
msgstr ""

#: ../../source/structuring.rst:151
msgid "To handle this, we'll update our definition of shipping address::"
msgstr ""

#: ../../source/structuring.rst:155
msgid ""
"to instead use an ``allOf`` keyword entry combining both the core address "
"schema definition and an extra schema snippet for the address type::"
msgstr ""

#: ../../source/structuring.rst:174
msgid "Tying this all together,"
msgstr ""

#: ../../source/structuring.rst:227
msgid ""
"From these basic pieces, it's possible to build very powerful constructions "
"without a lot of duplication."
msgstr ""

#: ../../source/structuring.rst:1
msgid "structure"
msgstr ""

#: ../../source/structuring.rst:62
msgid "$ref"
msgstr ""
